Subject: [PATCH] initial
---
Index: src/core/mainloop/connection.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/core/mainloop/connection.c b/src/core/mainloop/connection.c
--- a/src/core/mainloop/connection.c	(revision c2bbaa2fb0a7d6dde36237f4f08dc50ec9af571f)
+++ b/src/core/mainloop/connection.c	(date 1758391091906)
@@ -138,8 +138,12 @@
 #include <sys/un.h>
 #endif
 
+#include <sys/wait.h>
+
 #include "feature/dircommon/dir_connection_st.h"
 #include "feature/control/control_connection_st.h"
+#include "feature/dirclient/dir_server_st.h"
+#include "feature/nodelist/dirlist.h"
 #include "core/or/entry_connection_st.h"
 #include "core/or/listener_connection_st.h"
 #include "core/or/or_connection_st.h"
@@ -5821,6 +5825,86 @@
   const or_options_t *options = get_options();
 
   *is_pt_out = 0;
+
+  if (options->ProxyOnlyDirServers) {
+    static atomic_int proxy_agent_pid = 0;
+    static pthread_mutex_t proxy_agent_mutex = PTHREAD_MUTEX_INITIALIZER;
+    int use_proxy = 0;
+    /* check if not bootstrapped yet */
+    extern int bootstrap_percent;
+    if (bootstrap_percent < BOOTSTRAP_STATUS_DONE) {
+      use_proxy = 1;
+    } else {
+      /* check if the address is in the list */
+      SMARTLIST_FOREACH_BEGIN(router_get_trusted_dir_servers(), dir_server_t *, ds) {
+        if (tor_addr_eq(&conn->addr, &ds->ipv4_addr) || tor_addr_eq(&conn->addr, &ds->ipv6_addr)) {
+          use_proxy = 1;
+          break;
+        }
+      } SMARTLIST_FOREACH_END(ds);
+      /* check if the address is in the fallback list */
+      if (!use_proxy) {
+        SMARTLIST_FOREACH_BEGIN(router_get_fallback_dir_servers(), dir_server_t *, ds) {
+          if (tor_addr_eq(&conn->addr, &ds->ipv4_addr) || tor_addr_eq(&conn->addr, &ds->ipv6_addr)) {
+            use_proxy = 1;
+            break;
+          }
+        } SMARTLIST_FOREACH_END(ds);
+      }
+    }
+
+    char address[TOR_ADDR_BUF_LEN];
+    tor_addr_to_str(address, &conn->addr, sizeof(address), 1);
+
+    if (!use_proxy) {
+      tor_log(LOG_NOTICE, LD_CONTROL, "Using direct connection to %s:%d", address, (int)conn->port);
+      /* check if the agent is running */
+      if (proxy_agent_pid) {
+        pthread_mutex_lock(&proxy_agent_mutex);
+        if (proxy_agent_pid) {
+          kill(proxy_agent_pid, SIGTERM);
+          int status;
+          waitpid(proxy_agent_pid, &status, 0);
+          tor_log(LOG_NOTICE, LD_CONTROL, "Proxy agent pid %d killed", proxy_agent_pid);
+          proxy_agent_pid = 0;
+        }
+        pthread_mutex_unlock(&proxy_agent_mutex);
+      }
+      goto skip_proxy;
+    }
+    tor_log(LOG_NOTICE, LD_CONTROL, "Using proxy for dir server only at %s:%d", address, (int)conn->port);
+
+    if (options->ProxyOnlyDirServersAgent && !proxy_agent_pid) {
+      pthread_mutex_lock(&proxy_agent_mutex);
+      if (!proxy_agent_pid) {
+        proxy_agent_pid = fork();
+        if (proxy_agent_pid == -1) {
+          tor_log(LOG_ERR, LD_CONTROL, "Fork failed: %s", strerror(errno));
+          proxy_agent_pid = 0;
+        }
+        else if (proxy_agent_pid == 0) {
+          execl("/bin/sh", "sh", "-c", options->ProxyOnlyDirServersAgent, NULL);
+          tor_log(LOG_ERR, LD_CONTROL, "Agent exec `%s` failed: %s", options->ProxyOnlyDirServersAgent, strerror(errno));
+        } else {
+          tor_log(LOG_NOTICE, LD_CONTROL, "Proxy agent pid %d started", proxy_agent_pid);
+          sleep(3);
+        }
+      }
+      pthread_mutex_unlock(&proxy_agent_mutex);
+    }
+    else {
+      pthread_mutex_lock(&proxy_agent_mutex);
+      int status;
+      if (waitpid(proxy_agent_pid, &status, WNOHANG)) {
+        if (status) {
+          tor_log(LOG_ERR, LD_CONTROL, "Proxy agent pid %d exited", proxy_agent_pid);
+        }
+        proxy_agent_pid = 0;
+      }
+      pthread_mutex_unlock(&proxy_agent_mutex);
+    }
+  }
+
   /* Client Transport Plugins can use another proxy, but that should be hidden
    * from the rest of tor (as the plugin is responsible for dealing with the
    * proxy), check it first, then check the rest of the proxy types to allow
@@ -5867,6 +5951,7 @@
     return 0;
   }
 
+  skip_proxy:
   tor_addr_make_unspec(addr);
   *port = 0;
   *proxy_type = PROXY_NONE;
Index: src/app/config/or_options_st.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/app/config/or_options_st.h b/src/app/config/or_options_st.h
--- a/src/app/config/or_options_st.h	(revision c2bbaa2fb0a7d6dde36237f4f08dc50ec9af571f)
+++ b/src/app/config/or_options_st.h	(date 1758283621000)
@@ -467,6 +467,9 @@
   tor_addr_t TCPProxyAddr; /**< Derived from TCPProxy. */
   uint16_t TCPProxyPort; /**< Derived from TCPProxy. */
 
+  int ProxyOnlyDirServers; /**< If set then proxy only dir servers */
+  char *ProxyOnlyDirServersAgent; /**< Agent command to run prior using ProxyOnlyDirServers, if any */
+
   /** List of configuration lines for replacement directory authorities.
    * If you just want to replace one class of authority at a time,
    * use the "Alternate*Authority" options below instead. */
Index: src/app/config/config.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/app/config/config.c b/src/app/config/config.c
--- a/src/app/config/config.c	(revision c2bbaa2fb0a7d6dde36237f4f08dc50ec9af571f)
+++ b/src/app/config/config.c	(date 1758283686000)
@@ -538,6 +538,8 @@
   V(Socks5ProxyUsername,         STRING,   NULL),
   V(Socks5ProxyPassword,         STRING,   NULL),
   V(TCPProxy,                    STRING,   NULL),
+  V(ProxyOnlyDirServers,         BOOL,     "0"),
+  V(ProxyOnlyDirServersAgent,    STRING,   NULL),
   VAR_IMMUTABLE("KeyDirectory",  FILENAME, KeyDirectory_option, NULL),
   V(KeyDirectoryGroupReadable,   AUTOBOOL, "auto"),
   VAR_D("HSLayer2Nodes",         ROUTERSET,  HSLayer2Nodes,  NULL),
Index: src/feature/control/control_bootstrap.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/feature/control/control_bootstrap.c b/src/feature/control/control_bootstrap.c
--- a/src/feature/control/control_bootstrap.c	(revision c2bbaa2fb0a7d6dde36237f4f08dc50ec9af571f)
+++ b/src/feature/control/control_bootstrap.c	(date 1757494239000)
@@ -116,7 +116,7 @@
  * so we can guess context for the bootstrap messages which are
  * ambiguous. It starts at 'undef', but gets set to 'starting' while
  * Tor initializes. */
-static int bootstrap_percent = BOOTSTRAP_STATUS_UNDEF;
+int bootstrap_percent = BOOTSTRAP_STATUS_UNDEF;
 
 /** Like bootstrap_percent, but only takes on the enumerated values in
  * bootstrap_status_t.
